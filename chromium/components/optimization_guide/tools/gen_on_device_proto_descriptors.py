#!/usr/bin/env python
# Copyright 2023 The Chromium Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Code generator for proto descriptors used for on-device model execution.

This script generates a C++ source file containing the proto descriptors.
"""

try:
    from StringIO import StringIO  # for Python 2
except ImportError:
    from io import StringIO  # for Python 3
import optparse
import os
import collections
import re
import sys

_HERE_PATH = os.path.dirname(__file__)
_SRC_PATH = os.path.normpath(os.path.join(_HERE_PATH, '..', '..', '..'))
sys.path.insert(0, os.path.join(_SRC_PATH, 'third_party', 'protobuf',
                                'python'))

class Error(Exception):
  pass


def GenerateProtoDescriptors(out, includes, message_data):
  """Generate static array containing a list of constructors."""

  out.write('// DO NOT MODIFY. GENERATED BY gen_on_device_proto_descriptors.py\n')
  out.write('\n')

  out.write('#include "components/optimization_guide/core/model_execution/on_device_model_execution_proto_descriptors.h"')
  out.write('\n\n')

  for include in includes:
    out.write('#include %(include)s\n' % {'include': include})
  out.write('\n')

  out.write('namespace optimization_guide {\n')
  out.write('\n')
  out.write('namespace {\n')

  out.write("""std::optional<proto::Value> GetProtoValue(const google::protobuf::MessageLite& msg, const proto::ProtoField& proto_field, int32_t index) {
  if (index >= proto_field.proto_descriptors_size()) {
    return std::nullopt;
  }
  int32_t tag_number = proto_field.proto_descriptors(index).tag_number();
  """);

  for type_name, data in message_data.items():
    out.write('if (msg.GetTypeName() == "%s") {\n' % type_name)
    out.write('const %s casted_msg = static_cast<const %s&>(msg);\n' % (data['cpp_class_name'], data['cpp_class_name']))
    out.write('switch (tag_number) {\n')
    for f in data['fields']:
      if f['is_repeated']:
        continue
      out.write('case %d: {\n' % f['tag_number'])
      if f['type'] == 11:
        out.write('return GetProtoValue(casted_msg.%s(), proto_field, index+1);\n' % f['name'])
      else:
        out.write('proto::Value value;\n');
        if f['type'] in {1, 2}:
          out.write('value.set_float_value(static_cast<double>(casted_msg.%s()));\n' % f['name'])
        elif f['type'] in {3, 4}:
          out.write('value.set_int64_value(static_cast<int64_t>(casted_msg.%s()));\n' % f['name'])
        elif f['type'] in {5, 13, 14}:
          out.write('value.set_int32_value(static_cast<int32_t>(casted_msg.%s()));\n' % f['name'])
        elif f['type'] in {8}:
          out.write('value.set_boolean_value(casted_msg.%s());\n' % f['name'])
        elif f['type'] in {9}:
          out.write('value.set_string_value(casted_msg.%s());\n' % f['name'])
        else:
          raise Error()
        out.write('return value;\n')
      out.write('}\n')  # End case
    out.write('}\n') # End switch
    out.write('}\n\n') # End if statement
  out.write('return std::nullopt;\n')
  out.write('}\n\n') # End function

  out.write("""
    std::optional<proto::Any> SetProtoValue(const std::string& proto_name,
                                            const proto::ProtoField& proto_field,
                                            const std::string& value,
                                            int32_t index) {
      if (index >= proto_field.proto_descriptors_size()) {
        return std::nullopt;
      }
  """)
  for type_name, data in message_data.items():
    out.write('if (proto_name == "%s") {\n' % type_name)
    out.write('switch(proto_field.proto_descriptors(index).tag_number()) {\n')
    for f in data['fields']:
      if f['type'] == 9:
        out.write('case %d: {\n' % f['tag_number'])
        out.write('proto::Any any;\n')
        out.write('any.set_type_url("type.googleapis.com/%s");\n' % type_name)
        out.write('%s response_value;\n' % data['cpp_class_name'])
        out.write('response_value.set_%s(value);' % f['name'])
        out.write('response_value.SerializeToString(any.mutable_value());')
        out.write('return any;')
        out.write('}\n')
    out.write("""
    default:
      return std::nullopt;\n
    """)
    out.write('}')
    out.write('}\n') # End if statement

  out.write("""
      return std::nullopt;
    }
  """)

  out.write('}  // namespace\n\n')
  out.write("""
    std::optional<proto::Value> GetProtoValue(const google::protobuf::MessageLite& msg, const proto::ProtoField& proto_field) {
      return GetProtoValue(msg, proto_field, /*index=*/0);
    }

    std::optional<proto::Any> SetProtoValue(const std::string& proto_name,
                                            const proto::ProtoField& proto_field,
                                            const std::string& value) {
      return SetProtoValue(proto_name, proto_field, value, /*index=*/0);
    }
  """)
  out.write('}  // namespace optimization_guide\n')
  out.write('\n')


def main(argv):
  parser = optparse.OptionParser()
  parser.add_option('--input_file', action='append', default=[])
  parser.add_option('--output_cc')
  parser.add_option('--include', action='append', default=[])
  options, _ = parser.parse_args(argv)

  from google.protobuf import descriptor_pb2

  input_files = list(options.input_file)
  includes = list(options.include)

  # Write to standard output or file specified by --output_cc.
  out_cc = getattr(sys.stdout, 'buffer', sys.stdout)
  if options.output_cc:
    out_cc = open(options.output_cc, 'wb')

  fds_set = []
  for input_file in input_files:
    fds = descriptor_pb2.FileDescriptorSet()
    with open(input_file, 'rb') as fp:
      fds.ParseFromString(fp.read())
      fds_set.append(fds)


  msg_data = {}
  for fds in fds_set:
    for f in fds.file:
      for m in f.message_type:
        name = f.package + '.' + m.name
        msg_data[name] = {
          'cpp_class_name': name.replace('.', '::'),
          'fields': [],
        }
        for field in m.field:
          msg_data[name]['fields'].append({
            'tag_number': field.number,
            'name': field.name,
            'type': field.type,
            'is_repeated': field.label == 3,
            })

        for nested_type in m.nested_type:
          nested_name = name + '.' + nested_type.name
          msg_data[nested_name] = {
            'cpp_class_name': name.replace('.', '::') + '_' + nested_type.name,
            'fields': []
          }
          for field in nested_type.field:
            msg_data[nested_name]['fields'].append({
              'tag_number': field.number,
              'name': field.name,
              'type': field.type,
              'is_repeated': field.label == 3,
            })

  out_cc_str = StringIO()
  GenerateProtoDescriptors(out_cc_str, includes, msg_data)
  out_cc.write(out_cc_str.getvalue().encode('utf-8'))

  if options.output_cc:
    out_cc.close()

  return 0


if __name__ == '__main__':
  sys.exit(main(sys.argv[1:]))