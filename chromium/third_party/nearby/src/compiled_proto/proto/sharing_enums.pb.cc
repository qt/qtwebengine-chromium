// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/sharing_enums.proto

#include "proto/sharing_enums.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace location {
namespace nearby {
namespace proto {
namespace sharing {
}  // namespace sharing
}  // namespace proto
}  // namespace nearby
}  // namespace location
namespace location {
namespace nearby {
namespace proto {
namespace sharing {
bool EventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EventType_strings[60] = {};

static const char EventType_names[] =
  "ACCEPT_AGREEMENTS"
  "ACCEPT_FAST_INITIALIZATION"
  "ADD_CONTACT"
  "ADD_QUICK_SETTINGS_TILE"
  "ADVERTISE_DEVICE_PRESENCE_END"
  "ADVERTISE_DEVICE_PRESENCE_START"
  "APP_CRASH"
  "AUTO_DISMISS_FAST_INITIALIZATION"
  "CANCEL_CONNECTION"
  "CANCEL_RECEIVING_ATTACHMENTS"
  "CANCEL_SENDING_ATTACHMENTS"
  "DECLINE_AGREEMENTS"
  "DEFAULT_OPT_IN"
  "DESCRIBE_ATTACHMENTS"
  "DEVICE_SETTINGS"
  "DISCOVER_SHARE_TARGET"
  "DISMISS_FAST_INITIALIZATION"
  "DISMISS_PRIVACY_NOTIFICATION"
  "DISPLAY_PHONE_CONSENT"
  "DISPLAY_PRIVACY_NOTIFICATION"
  "ENABLE_NEARBY_SHARING"
  "ESTABLISH_CONNECTION"
  "FAST_SHARE_SERVER_RESPONSE"
  "INSTALL_APK"
  "LAUNCH_ACTIVITY"
  "LAUNCH_CONSENT"
  "LAUNCH_PHONE_CONSENT"
  "LAUNCH_SETUP_ACTIVITY"
  "OPEN_RECEIVED_ATTACHMENTS"
  "PREFERENCES_USAGE"
  "PROCESS_RECEIVED_ATTACHMENTS_END"
  "QR_CODE_LINK_SHOWN"
  "RECEIVE_ATTACHMENTS_END"
  "RECEIVE_ATTACHMENTS_START"
  "RECEIVE_FAST_INITIALIZATION"
  "RECEIVE_INTRODUCTION"
  "REMOVE_CONTACT"
  "REMOVE_QUICK_SETTINGS_TILE"
  "REQUEST_SETTING_PERMISSIONS"
  "RESPOND_TO_INTRODUCTION"
  "SCAN_FOR_SHARE_TARGETS_END"
  "SCAN_FOR_SHARE_TARGETS_START"
  "SEND_ATTACHMENTS_END"
  "SEND_ATTACHMENTS_START"
  "SEND_FAST_INITIALIZATION"
  "SEND_INTRODUCTION"
  "SEND_START"
  "SETUP_WIZARD"
  "SET_DATA_USAGE"
  "SET_DEVICE_NAME"
  "SET_VISIBILITY"
  "TAP_FEEDBACK"
  "TAP_HELP"
  "TAP_PRIVACY_NOTIFICATION"
  "TAP_QR_CODE"
  "TAP_QUICK_SETTINGS_FILE_SHARE"
  "TAP_QUICK_SETTINGS_TILE"
  "TOGGLE_SHOW_NOTIFICATION"
  "UNKNOWN_EVENT_TYPE"
  "VERIFY_APK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EventType_entries[] = {
  { {EventType_names + 0, 17}, 1 },
  { {EventType_names + 17, 26}, 27 },
  { {EventType_names + 43, 11}, 23 },
  { {EventType_names + 54, 23}, 36 },
  { {EventType_names + 77, 29}, 8 },
  { {EventType_names + 106, 31}, 7 },
  { {EventType_names + 137, 9}, 51 },
  { {EventType_names + 146, 32}, 50 },
  { {EventType_names + 178, 17}, 30 },
  { {EventType_names + 195, 28}, 20 },
  { {EventType_names + 223, 26}, 19 },
  { {EventType_names + 249, 18}, 46 },
  { {EventType_names + 267, 14}, 56 },
  { {EventType_names + 281, 20}, 4 },
  { {EventType_names + 301, 15}, 49 },
  { {EventType_names + 316, 21}, 11 },
  { {EventType_names + 337, 27}, 29 },
  { {EventType_names + 364, 28}, 32 },
  { {EventType_names + 392, 21}, 54 },
  { {EventType_names + 413, 28}, 53 },
  { {EventType_names + 441, 21}, 2 },
  { {EventType_names + 462, 20}, 48 },
  { {EventType_names + 482, 26}, 25 },
  { {EventType_names + 508, 11}, 40 },
  { {EventType_names + 519, 15}, 31 },
  { {EventType_names + 534, 14}, 42 },
  { {EventType_names + 548, 20}, 38 },
  { {EventType_names + 568, 21}, 22 },
  { {EventType_names + 589, 25}, 21 },
  { {EventType_names + 614, 17}, 55 },
  { {EventType_names + 631, 32}, 43 },
  { {EventType_names + 663, 18}, 59 },
  { {EventType_names + 681, 23}, 18 },
  { {EventType_names + 704, 25}, 17 },
  { {EventType_names + 729, 27}, 10 },
  { {EventType_names + 756, 20}, 13 },
  { {EventType_names + 776, 14}, 24 },
  { {EventType_names + 790, 26}, 37 },
  { {EventType_names + 816, 27}, 47 },
  { {EventType_names + 843, 23}, 14 },
  { {EventType_names + 866, 26}, 6 },
  { {EventType_names + 892, 28}, 5 },
  { {EventType_names + 920, 20}, 16 },
  { {EventType_names + 940, 22}, 15 },
  { {EventType_names + 962, 24}, 9 },
  { {EventType_names + 986, 17}, 12 },
  { {EventType_names + 1003, 10}, 26 },
  { {EventType_names + 1013, 12}, 57 },
  { {EventType_names + 1025, 14}, 28 },
  { {EventType_names + 1039, 15}, 45 },
  { {EventType_names + 1054, 14}, 3 },
  { {EventType_names + 1068, 12}, 35 },
  { {EventType_names + 1080, 8}, 34 },
  { {EventType_names + 1088, 24}, 33 },
  { {EventType_names + 1112, 11}, 58 },
  { {EventType_names + 1123, 29}, 52 },
  { {EventType_names + 1152, 23}, 39 },
  { {EventType_names + 1175, 24}, 44 },
  { {EventType_names + 1199, 18}, 0 },
  { {EventType_names + 1217, 10}, 41 },
};

static const int EventType_entries_by_number[] = {
  58, // 0 -> UNKNOWN_EVENT_TYPE
  0, // 1 -> ACCEPT_AGREEMENTS
  20, // 2 -> ENABLE_NEARBY_SHARING
  50, // 3 -> SET_VISIBILITY
  13, // 4 -> DESCRIBE_ATTACHMENTS
  41, // 5 -> SCAN_FOR_SHARE_TARGETS_START
  40, // 6 -> SCAN_FOR_SHARE_TARGETS_END
  5, // 7 -> ADVERTISE_DEVICE_PRESENCE_START
  4, // 8 -> ADVERTISE_DEVICE_PRESENCE_END
  44, // 9 -> SEND_FAST_INITIALIZATION
  34, // 10 -> RECEIVE_FAST_INITIALIZATION
  15, // 11 -> DISCOVER_SHARE_TARGET
  45, // 12 -> SEND_INTRODUCTION
  35, // 13 -> RECEIVE_INTRODUCTION
  39, // 14 -> RESPOND_TO_INTRODUCTION
  43, // 15 -> SEND_ATTACHMENTS_START
  42, // 16 -> SEND_ATTACHMENTS_END
  33, // 17 -> RECEIVE_ATTACHMENTS_START
  32, // 18 -> RECEIVE_ATTACHMENTS_END
  10, // 19 -> CANCEL_SENDING_ATTACHMENTS
  9, // 20 -> CANCEL_RECEIVING_ATTACHMENTS
  28, // 21 -> OPEN_RECEIVED_ATTACHMENTS
  27, // 22 -> LAUNCH_SETUP_ACTIVITY
  2, // 23 -> ADD_CONTACT
  36, // 24 -> REMOVE_CONTACT
  22, // 25 -> FAST_SHARE_SERVER_RESPONSE
  46, // 26 -> SEND_START
  1, // 27 -> ACCEPT_FAST_INITIALIZATION
  48, // 28 -> SET_DATA_USAGE
  16, // 29 -> DISMISS_FAST_INITIALIZATION
  8, // 30 -> CANCEL_CONNECTION
  24, // 31 -> LAUNCH_ACTIVITY
  17, // 32 -> DISMISS_PRIVACY_NOTIFICATION
  53, // 33 -> TAP_PRIVACY_NOTIFICATION
  52, // 34 -> TAP_HELP
  51, // 35 -> TAP_FEEDBACK
  3, // 36 -> ADD_QUICK_SETTINGS_TILE
  37, // 37 -> REMOVE_QUICK_SETTINGS_TILE
  26, // 38 -> LAUNCH_PHONE_CONSENT
  56, // 39 -> TAP_QUICK_SETTINGS_TILE
  23, // 40 -> INSTALL_APK
  59, // 41 -> VERIFY_APK
  25, // 42 -> LAUNCH_CONSENT
  30, // 43 -> PROCESS_RECEIVED_ATTACHMENTS_END
  57, // 44 -> TOGGLE_SHOW_NOTIFICATION
  49, // 45 -> SET_DEVICE_NAME
  11, // 46 -> DECLINE_AGREEMENTS
  38, // 47 -> REQUEST_SETTING_PERMISSIONS
  21, // 48 -> ESTABLISH_CONNECTION
  14, // 49 -> DEVICE_SETTINGS
  7, // 50 -> AUTO_DISMISS_FAST_INITIALIZATION
  6, // 51 -> APP_CRASH
  55, // 52 -> TAP_QUICK_SETTINGS_FILE_SHARE
  19, // 53 -> DISPLAY_PRIVACY_NOTIFICATION
  18, // 54 -> DISPLAY_PHONE_CONSENT
  29, // 55 -> PREFERENCES_USAGE
  12, // 56 -> DEFAULT_OPT_IN
  47, // 57 -> SETUP_WIZARD
  54, // 58 -> TAP_QR_CODE
  31, // 59 -> QR_CODE_LINK_SHOWN
};

const std::string& EventType_Name(
    EventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EventType_entries,
          EventType_entries_by_number,
          60, EventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EventType_entries,
      EventType_entries_by_number,
      60, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EventType_strings[idx].get();
}
bool EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EventType_entries, 60, name, &int_value);
  if (success) {
    *value = static_cast<EventType>(int_value);
  }
  return success;
}
bool EventCategory_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EventCategory_strings[4] = {};

static const char EventCategory_names[] =
  "RECEIVING_EVENT"
  "SENDING_EVENT"
  "SETTINGS_EVENT"
  "UNKNOWN_EVENT_CATEGORY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EventCategory_entries[] = {
  { {EventCategory_names + 0, 15}, 2 },
  { {EventCategory_names + 15, 13}, 1 },
  { {EventCategory_names + 28, 14}, 3 },
  { {EventCategory_names + 42, 22}, 0 },
};

static const int EventCategory_entries_by_number[] = {
  3, // 0 -> UNKNOWN_EVENT_CATEGORY
  1, // 1 -> SENDING_EVENT
  0, // 2 -> RECEIVING_EVENT
  2, // 3 -> SETTINGS_EVENT
};

const std::string& EventCategory_Name(
    EventCategory value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EventCategory_entries,
          EventCategory_entries_by_number,
          4, EventCategory_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EventCategory_entries,
      EventCategory_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EventCategory_strings[idx].get();
}
bool EventCategory_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventCategory* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EventCategory_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<EventCategory>(int_value);
  }
  return success;
}
bool NearbySharingStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NearbySharingStatus_strings[3] = {};

static const char NearbySharingStatus_names[] =
  "OFF"
  "ON"
  "UNKNOWN_NEARBY_SHARING_STATUS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NearbySharingStatus_entries[] = {
  { {NearbySharingStatus_names + 0, 3}, 2 },
  { {NearbySharingStatus_names + 3, 2}, 1 },
  { {NearbySharingStatus_names + 5, 29}, 0 },
};

static const int NearbySharingStatus_entries_by_number[] = {
  2, // 0 -> UNKNOWN_NEARBY_SHARING_STATUS
  1, // 1 -> ON
  0, // 2 -> OFF
};

const std::string& NearbySharingStatus_Name(
    NearbySharingStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NearbySharingStatus_entries,
          NearbySharingStatus_entries_by_number,
          3, NearbySharingStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NearbySharingStatus_entries,
      NearbySharingStatus_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NearbySharingStatus_strings[idx].get();
}
bool NearbySharingStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NearbySharingStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NearbySharingStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<NearbySharingStatus>(int_value);
  }
  return success;
}
bool Visibility_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Visibility_strings[6] = {};

static const char Visibility_names[] =
  "CONTACTS_ONLY"
  "EVERYONE"
  "HIDDEN"
  "SELECTED_CONTACTS_ONLY"
  "SELF_SHARE"
  "UNKNOWN_VISIBILITY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Visibility_entries[] = {
  { {Visibility_names + 0, 13}, 1 },
  { {Visibility_names + 13, 8}, 2 },
  { {Visibility_names + 21, 6}, 4 },
  { {Visibility_names + 27, 22}, 3 },
  { {Visibility_names + 49, 10}, 5 },
  { {Visibility_names + 59, 18}, 0 },
};

static const int Visibility_entries_by_number[] = {
  5, // 0 -> UNKNOWN_VISIBILITY
  0, // 1 -> CONTACTS_ONLY
  1, // 2 -> EVERYONE
  3, // 3 -> SELECTED_CONTACTS_ONLY
  2, // 4 -> HIDDEN
  4, // 5 -> SELF_SHARE
};

const std::string& Visibility_Name(
    Visibility value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Visibility_entries,
          Visibility_entries_by_number,
          6, Visibility_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Visibility_entries,
      Visibility_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Visibility_strings[idx].get();
}
bool Visibility_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Visibility* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Visibility_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<Visibility>(int_value);
  }
  return success;
}
bool DataUsage_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DataUsage_strings[4] = {};

static const char DataUsage_names[] =
  "OFFLINE"
  "ONLINE"
  "UNKNOWN_DATA_USAGE"
  "WIFI_ONLY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DataUsage_entries[] = {
  { {DataUsage_names + 0, 7}, 3 },
  { {DataUsage_names + 7, 6}, 1 },
  { {DataUsage_names + 13, 18}, 0 },
  { {DataUsage_names + 31, 9}, 2 },
};

static const int DataUsage_entries_by_number[] = {
  2, // 0 -> UNKNOWN_DATA_USAGE
  1, // 1 -> ONLINE
  3, // 2 -> WIFI_ONLY
  0, // 3 -> OFFLINE
};

const std::string& DataUsage_Name(
    DataUsage value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DataUsage_entries,
          DataUsage_entries_by_number,
          4, DataUsage_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DataUsage_entries,
      DataUsage_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DataUsage_strings[idx].get();
}
bool DataUsage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataUsage* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DataUsage_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DataUsage>(int_value);
  }
  return success;
}
bool EstablishConnectionStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EstablishConnectionStatus_strings[4] = {};

static const char EstablishConnectionStatus_names[] =
  "CONNECTION_STATUS_CANCELLATION"
  "CONNECTION_STATUS_FAILURE"
  "CONNECTION_STATUS_SUCCESS"
  "CONNECTION_STATUS_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EstablishConnectionStatus_entries[] = {
  { {EstablishConnectionStatus_names + 0, 30}, 3 },
  { {EstablishConnectionStatus_names + 30, 25}, 2 },
  { {EstablishConnectionStatus_names + 55, 25}, 1 },
  { {EstablishConnectionStatus_names + 80, 25}, 0 },
};

static const int EstablishConnectionStatus_entries_by_number[] = {
  3, // 0 -> CONNECTION_STATUS_UNKNOWN
  2, // 1 -> CONNECTION_STATUS_SUCCESS
  1, // 2 -> CONNECTION_STATUS_FAILURE
  0, // 3 -> CONNECTION_STATUS_CANCELLATION
};

const std::string& EstablishConnectionStatus_Name(
    EstablishConnectionStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EstablishConnectionStatus_entries,
          EstablishConnectionStatus_entries_by_number,
          4, EstablishConnectionStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EstablishConnectionStatus_entries,
      EstablishConnectionStatus_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EstablishConnectionStatus_strings[idx].get();
}
bool EstablishConnectionStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EstablishConnectionStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EstablishConnectionStatus_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<EstablishConnectionStatus>(int_value);
  }
  return success;
}
bool AttachmentTransmissionStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AttachmentTransmissionStatus_strings[18] = {};

static const char AttachmentTransmissionStatus_names[] =
  "AWAITING_REMOTE_ACCEPTANCE_FAILED_ATTACHMENT"
  "CANCELED_ATTACHMENT_TRANSMISSION_STATUS"
  "COMPLETE_ATTACHMENT_TRANSMISSION_STATUS"
  "FAILED_ATTACHMENT_TRANSMISSION_STATUS"
  "FAILED_NO_PAYLOAD"
  "FAILED_NO_SHARE_TARGET_ENDPOINT"
  "FAILED_NO_TRANSFER_UPDATE_CALLBACK"
  "FAILED_NULL_CONNECTION"
  "FAILED_PAIRED_KEYHANDSHAKE"
  "FAILED_UNKNOWN_REMOTE_RESPONSE"
  "FAILED_WRITE_INTRODUCTION"
  "MEDIA_UNAVAILABLE_ATTACHMENT"
  "NOT_ENOUGH_SPACE_ATTACHMENT"
  "NO_ATTACHMENT_FOUND"
  "REJECTED_ATTACHMENT"
  "TIMED_OUT_ATTACHMENT"
  "UNKNOWN_ATTACHMENT_TRANSMISSION_STATUS"
  "UNSUPPORTED_ATTACHMENT_TYPE_ATTACHMENT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AttachmentTransmissionStatus_entries[] = {
  { {AttachmentTransmissionStatus_names + 0, 44}, 6 },
  { {AttachmentTransmissionStatus_names + 44, 39}, 2 },
  { {AttachmentTransmissionStatus_names + 83, 39}, 1 },
  { {AttachmentTransmissionStatus_names + 122, 37}, 3 },
  { {AttachmentTransmissionStatus_names + 159, 17}, 15 },
  { {AttachmentTransmissionStatus_names + 176, 31}, 12 },
  { {AttachmentTransmissionStatus_names + 207, 34}, 8 },
  { {AttachmentTransmissionStatus_names + 241, 22}, 14 },
  { {AttachmentTransmissionStatus_names + 263, 26}, 13 },
  { {AttachmentTransmissionStatus_names + 289, 30}, 17 },
  { {AttachmentTransmissionStatus_names + 319, 25}, 16 },
  { {AttachmentTransmissionStatus_names + 344, 28}, 9 },
  { {AttachmentTransmissionStatus_names + 372, 27}, 7 },
  { {AttachmentTransmissionStatus_names + 399, 19}, 11 },
  { {AttachmentTransmissionStatus_names + 418, 19}, 4 },
  { {AttachmentTransmissionStatus_names + 437, 20}, 5 },
  { {AttachmentTransmissionStatus_names + 457, 38}, 0 },
  { {AttachmentTransmissionStatus_names + 495, 38}, 10 },
};

static const int AttachmentTransmissionStatus_entries_by_number[] = {
  16, // 0 -> UNKNOWN_ATTACHMENT_TRANSMISSION_STATUS
  2, // 1 -> COMPLETE_ATTACHMENT_TRANSMISSION_STATUS
  1, // 2 -> CANCELED_ATTACHMENT_TRANSMISSION_STATUS
  3, // 3 -> FAILED_ATTACHMENT_TRANSMISSION_STATUS
  14, // 4 -> REJECTED_ATTACHMENT
  15, // 5 -> TIMED_OUT_ATTACHMENT
  0, // 6 -> AWAITING_REMOTE_ACCEPTANCE_FAILED_ATTACHMENT
  12, // 7 -> NOT_ENOUGH_SPACE_ATTACHMENT
  6, // 8 -> FAILED_NO_TRANSFER_UPDATE_CALLBACK
  11, // 9 -> MEDIA_UNAVAILABLE_ATTACHMENT
  17, // 10 -> UNSUPPORTED_ATTACHMENT_TYPE_ATTACHMENT
  13, // 11 -> NO_ATTACHMENT_FOUND
  5, // 12 -> FAILED_NO_SHARE_TARGET_ENDPOINT
  8, // 13 -> FAILED_PAIRED_KEYHANDSHAKE
  7, // 14 -> FAILED_NULL_CONNECTION
  4, // 15 -> FAILED_NO_PAYLOAD
  10, // 16 -> FAILED_WRITE_INTRODUCTION
  9, // 17 -> FAILED_UNKNOWN_REMOTE_RESPONSE
};

const std::string& AttachmentTransmissionStatus_Name(
    AttachmentTransmissionStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AttachmentTransmissionStatus_entries,
          AttachmentTransmissionStatus_entries_by_number,
          18, AttachmentTransmissionStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AttachmentTransmissionStatus_entries,
      AttachmentTransmissionStatus_entries_by_number,
      18, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AttachmentTransmissionStatus_strings[idx].get();
}
bool AttachmentTransmissionStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AttachmentTransmissionStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AttachmentTransmissionStatus_entries, 18, name, &int_value);
  if (success) {
    *value = static_cast<AttachmentTransmissionStatus>(int_value);
  }
  return success;
}
bool ProcessReceivedAttachmentsStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ProcessReceivedAttachmentsStatus_strings[6] = {};

static const char ProcessReceivedAttachmentsStatus_names[] =
  "PROCESSING_STATUS_COMPLETE_PROCESSING_ATTACHMENTS"
  "PROCESSING_STATUS_FAILED_MOVING_FILES"
  "PROCESSING_STATUS_FAILED_RECEIVING_APK"
  "PROCESSING_STATUS_FAILED_RECEIVING_TEXT"
  "PROCESSING_STATUS_FAILED_RECEIVING_WIFI_CREDENTIALS"
  "PROCESSING_STATUS_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ProcessReceivedAttachmentsStatus_entries[] = {
  { {ProcessReceivedAttachmentsStatus_names + 0, 49}, 1 },
  { {ProcessReceivedAttachmentsStatus_names + 49, 37}, 2 },
  { {ProcessReceivedAttachmentsStatus_names + 86, 38}, 3 },
  { {ProcessReceivedAttachmentsStatus_names + 124, 39}, 4 },
  { {ProcessReceivedAttachmentsStatus_names + 163, 51}, 5 },
  { {ProcessReceivedAttachmentsStatus_names + 214, 25}, 0 },
};

static const int ProcessReceivedAttachmentsStatus_entries_by_number[] = {
  5, // 0 -> PROCESSING_STATUS_UNKNOWN
  0, // 1 -> PROCESSING_STATUS_COMPLETE_PROCESSING_ATTACHMENTS
  1, // 2 -> PROCESSING_STATUS_FAILED_MOVING_FILES
  2, // 3 -> PROCESSING_STATUS_FAILED_RECEIVING_APK
  3, // 4 -> PROCESSING_STATUS_FAILED_RECEIVING_TEXT
  4, // 5 -> PROCESSING_STATUS_FAILED_RECEIVING_WIFI_CREDENTIALS
};

const std::string& ProcessReceivedAttachmentsStatus_Name(
    ProcessReceivedAttachmentsStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ProcessReceivedAttachmentsStatus_entries,
          ProcessReceivedAttachmentsStatus_entries_by_number,
          6, ProcessReceivedAttachmentsStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ProcessReceivedAttachmentsStatus_entries,
      ProcessReceivedAttachmentsStatus_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ProcessReceivedAttachmentsStatus_strings[idx].get();
}
bool ProcessReceivedAttachmentsStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProcessReceivedAttachmentsStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ProcessReceivedAttachmentsStatus_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<ProcessReceivedAttachmentsStatus>(int_value);
  }
  return success;
}
bool SessionStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SessionStatus_strings[3] = {};

static const char SessionStatus_names[] =
  "FAILED_SESSION_STATUS"
  "SUCCEEDED_SESSION_STATUS"
  "UNKNOWN_SESSION_STATUS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SessionStatus_entries[] = {
  { {SessionStatus_names + 0, 21}, 2 },
  { {SessionStatus_names + 21, 24}, 1 },
  { {SessionStatus_names + 45, 22}, 0 },
};

static const int SessionStatus_entries_by_number[] = {
  2, // 0 -> UNKNOWN_SESSION_STATUS
  1, // 1 -> SUCCEEDED_SESSION_STATUS
  0, // 2 -> FAILED_SESSION_STATUS
};

const std::string& SessionStatus_Name(
    SessionStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SessionStatus_entries,
          SessionStatus_entries_by_number,
          3, SessionStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SessionStatus_entries,
      SessionStatus_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SessionStatus_strings[idx].get();
}
bool SessionStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SessionStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<SessionStatus>(int_value);
  }
  return success;
}
bool ResponseToIntroduction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ResponseToIntroduction_strings[4] = {};

static const char ResponseToIntroduction_names[] =
  "ACCEPT_INTRODUCTION"
  "FAIL_INTRODUCTION"
  "REJECT_INTRODUCTION"
  "UNKNOWN_RESPONSE_TO_INTRODUCTION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ResponseToIntroduction_entries[] = {
  { {ResponseToIntroduction_names + 0, 19}, 1 },
  { {ResponseToIntroduction_names + 19, 17}, 3 },
  { {ResponseToIntroduction_names + 36, 19}, 2 },
  { {ResponseToIntroduction_names + 55, 32}, 0 },
};

static const int ResponseToIntroduction_entries_by_number[] = {
  3, // 0 -> UNKNOWN_RESPONSE_TO_INTRODUCTION
  0, // 1 -> ACCEPT_INTRODUCTION
  2, // 2 -> REJECT_INTRODUCTION
  1, // 3 -> FAIL_INTRODUCTION
};

const std::string& ResponseToIntroduction_Name(
    ResponseToIntroduction value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ResponseToIntroduction_entries,
          ResponseToIntroduction_entries_by_number,
          4, ResponseToIntroduction_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ResponseToIntroduction_entries,
      ResponseToIntroduction_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ResponseToIntroduction_strings[idx].get();
}
bool ResponseToIntroduction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResponseToIntroduction* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ResponseToIntroduction_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ResponseToIntroduction>(int_value);
  }
  return success;
}
bool DeviceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceType_strings[4] = {};

static const char DeviceType_names[] =
  "LAPTOP"
  "PHONE"
  "TABLET"
  "UNKNOWN_DEVICE_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceType_entries[] = {
  { {DeviceType_names + 0, 6}, 3 },
  { {DeviceType_names + 6, 5}, 1 },
  { {DeviceType_names + 11, 6}, 2 },
  { {DeviceType_names + 17, 19}, 0 },
};

static const int DeviceType_entries_by_number[] = {
  3, // 0 -> UNKNOWN_DEVICE_TYPE
  1, // 1 -> PHONE
  2, // 2 -> TABLET
  0, // 3 -> LAPTOP
};

const std::string& DeviceType_Name(
    DeviceType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceType_entries,
          DeviceType_entries_by_number,
          4, DeviceType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceType_entries,
      DeviceType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceType_strings[idx].get();
}
bool DeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DeviceType>(int_value);
  }
  return success;
}
bool OSType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> OSType_strings[5] = {};

static const char OSType_names[] =
  "ANDROID"
  "CHROME_OS"
  "IOS"
  "UNKNOWN_OS_TYPE"
  "WINDOWS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry OSType_entries[] = {
  { {OSType_names + 0, 7}, 1 },
  { {OSType_names + 7, 9}, 2 },
  { {OSType_names + 16, 3}, 3 },
  { {OSType_names + 19, 15}, 0 },
  { {OSType_names + 34, 7}, 4 },
};

static const int OSType_entries_by_number[] = {
  3, // 0 -> UNKNOWN_OS_TYPE
  0, // 1 -> ANDROID
  1, // 2 -> CHROME_OS
  2, // 3 -> IOS
  4, // 4 -> WINDOWS
};

const std::string& OSType_Name(
    OSType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          OSType_entries,
          OSType_entries_by_number,
          5, OSType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      OSType_entries,
      OSType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     OSType_strings[idx].get();
}
bool OSType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OSType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      OSType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<OSType>(int_value);
  }
  return success;
}
bool DeviceRelationship_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceRelationship_strings[4] = {};

static const char DeviceRelationship_names[] =
  "IS_CONTACT"
  "IS_SELF"
  "IS_STRANGER"
  "UNKNOWN_DEVICE_RELATIONSHIP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceRelationship_entries[] = {
  { {DeviceRelationship_names + 0, 10}, 2 },
  { {DeviceRelationship_names + 10, 7}, 1 },
  { {DeviceRelationship_names + 17, 11}, 3 },
  { {DeviceRelationship_names + 28, 27}, 0 },
};

static const int DeviceRelationship_entries_by_number[] = {
  3, // 0 -> UNKNOWN_DEVICE_RELATIONSHIP
  1, // 1 -> IS_SELF
  0, // 2 -> IS_CONTACT
  2, // 3 -> IS_STRANGER
};

const std::string& DeviceRelationship_Name(
    DeviceRelationship value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceRelationship_entries,
          DeviceRelationship_entries_by_number,
          4, DeviceRelationship_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceRelationship_entries,
      DeviceRelationship_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceRelationship_strings[idx].get();
}
bool DeviceRelationship_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceRelationship* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceRelationship_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DeviceRelationship>(int_value);
  }
  return success;
}
bool LogSource_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LogSource_strings[7] = {};

static const char LogSource_names[] =
  "BETA_TESTER_DEVICES"
  "DEBUG_DEVICES"
  "INTERNAL_DEVICES"
  "LAB_DEVICES"
  "NEARBY_MODULE_FOOD_DEVICES"
  "OEM_DEVICES"
  "UNSPECIFIED_SOURCE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LogSource_entries[] = {
  { {LogSource_names + 0, 19}, 3 },
  { {LogSource_names + 19, 13}, 5 },
  { {LogSource_names + 32, 16}, 2 },
  { {LogSource_names + 48, 11}, 1 },
  { {LogSource_names + 59, 26}, 6 },
  { {LogSource_names + 85, 11}, 4 },
  { {LogSource_names + 96, 18}, 0 },
};

static const int LogSource_entries_by_number[] = {
  6, // 0 -> UNSPECIFIED_SOURCE
  3, // 1 -> LAB_DEVICES
  2, // 2 -> INTERNAL_DEVICES
  0, // 3 -> BETA_TESTER_DEVICES
  5, // 4 -> OEM_DEVICES
  1, // 5 -> DEBUG_DEVICES
  4, // 6 -> NEARBY_MODULE_FOOD_DEVICES
};

const std::string& LogSource_Name(
    LogSource value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LogSource_entries,
          LogSource_entries_by_number,
          7, LogSource_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LogSource_entries,
      LogSource_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LogSource_strings[idx].get();
}
bool LogSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogSource* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LogSource_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<LogSource>(int_value);
  }
  return success;
}
bool ServerActionName_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServerActionName_strings[11] = {};

static const char ServerActionName_names[] =
  "CHECK_REACHABILITY"
  "DOWNLOAD_CERTIFICATES"
  "DOWNLOAD_SENDER_CERTIFICATES"
  "LIST_MY_DEVICES"
  "LIST_REACHABLE_PHONE_NUMBERS"
  "UNKNOWN_SERVER_ACTION"
  "UPDATE_DEVICE_NAME"
  "UPLOAD_CERTIFICATES"
  "UPLOAD_CONTACTS"
  "UPLOAD_CONTACTS_AND_CERTIFICATES"
  "UPLOAD_SENDER_CERTIFICATES";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServerActionName_entries[] = {
  { {ServerActionName_names + 0, 18}, 3 },
  { {ServerActionName_names + 18, 21}, 2 },
  { {ServerActionName_names + 39, 28}, 7 },
  { {ServerActionName_names + 67, 15}, 10 },
  { {ServerActionName_names + 82, 28}, 9 },
  { {ServerActionName_names + 110, 21}, 0 },
  { {ServerActionName_names + 131, 18}, 5 },
  { {ServerActionName_names + 149, 19}, 1 },
  { {ServerActionName_names + 168, 15}, 4 },
  { {ServerActionName_names + 183, 32}, 8 },
  { {ServerActionName_names + 215, 26}, 6 },
};

static const int ServerActionName_entries_by_number[] = {
  5, // 0 -> UNKNOWN_SERVER_ACTION
  7, // 1 -> UPLOAD_CERTIFICATES
  1, // 2 -> DOWNLOAD_CERTIFICATES
  0, // 3 -> CHECK_REACHABILITY
  8, // 4 -> UPLOAD_CONTACTS
  6, // 5 -> UPDATE_DEVICE_NAME
  10, // 6 -> UPLOAD_SENDER_CERTIFICATES
  2, // 7 -> DOWNLOAD_SENDER_CERTIFICATES
  9, // 8 -> UPLOAD_CONTACTS_AND_CERTIFICATES
  4, // 9 -> LIST_REACHABLE_PHONE_NUMBERS
  3, // 10 -> LIST_MY_DEVICES
};

const std::string& ServerActionName_Name(
    ServerActionName value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ServerActionName_entries,
          ServerActionName_entries_by_number,
          11, ServerActionName_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ServerActionName_entries,
      ServerActionName_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ServerActionName_strings[idx].get();
}
bool ServerActionName_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServerActionName* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ServerActionName_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<ServerActionName>(int_value);
  }
  return success;
}
bool ServerResponseState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServerResponseState_strings[11] = {};

static const char ServerResponseState_names[] =
  "SERVER_RESPONSE_GOOGLE_AUTH_FAILURE"
  "SERVER_RESPONSE_NOT_CONNECTED_TO_INTERNET"
  "SERVER_RESPONSE_STATUS_DEADLINE_EXCEEDED"
  "SERVER_RESPONSE_STATUS_INVALID_ARGUMENT"
  "SERVER_RESPONSE_STATUS_OTHER_FAILURE"
  "SERVER_RESPONSE_STATUS_PERMISSION_DENIED"
  "SERVER_RESPONSE_STATUS_UNAUTHENTICATED"
  "SERVER_RESPONSE_STATUS_UNAVAILABLE"
  "SERVER_RESPONSE_SUCCESS"
  "SERVER_RESPONSE_UNKNOWN_FAILURE"
  "UNKNOWN_SERVER_RESPONSE_STATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServerResponseState_entries[] = {
  { {ServerResponseState_names + 0, 35}, 8 },
  { {ServerResponseState_names + 35, 41}, 10 },
  { {ServerResponseState_names + 76, 40}, 4 },
  { {ServerResponseState_names + 116, 39}, 9 },
  { {ServerResponseState_names + 155, 36}, 3 },
  { {ServerResponseState_names + 191, 40}, 5 },
  { {ServerResponseState_names + 231, 38}, 7 },
  { {ServerResponseState_names + 269, 34}, 6 },
  { {ServerResponseState_names + 303, 23}, 1 },
  { {ServerResponseState_names + 326, 31}, 2 },
  { {ServerResponseState_names + 357, 29}, 0 },
};

static const int ServerResponseState_entries_by_number[] = {
  10, // 0 -> UNKNOWN_SERVER_RESPONSE_STATE
  8, // 1 -> SERVER_RESPONSE_SUCCESS
  9, // 2 -> SERVER_RESPONSE_UNKNOWN_FAILURE
  4, // 3 -> SERVER_RESPONSE_STATUS_OTHER_FAILURE
  2, // 4 -> SERVER_RESPONSE_STATUS_DEADLINE_EXCEEDED
  5, // 5 -> SERVER_RESPONSE_STATUS_PERMISSION_DENIED
  7, // 6 -> SERVER_RESPONSE_STATUS_UNAVAILABLE
  6, // 7 -> SERVER_RESPONSE_STATUS_UNAUTHENTICATED
  0, // 8 -> SERVER_RESPONSE_GOOGLE_AUTH_FAILURE
  3, // 9 -> SERVER_RESPONSE_STATUS_INVALID_ARGUMENT
  1, // 10 -> SERVER_RESPONSE_NOT_CONNECTED_TO_INTERNET
};

const std::string& ServerResponseState_Name(
    ServerResponseState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ServerResponseState_entries,
          ServerResponseState_entries_by_number,
          11, ServerResponseState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ServerResponseState_entries,
      ServerResponseState_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ServerResponseState_strings[idx].get();
}
bool ServerResponseState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServerResponseState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ServerResponseState_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<ServerResponseState>(int_value);
  }
  return success;
}
bool ScanType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ScanType_strings[5] = {};

static const char ScanType_names[] =
  "BACKGROUND_SCAN"
  "DIRECT_SHARE_SCAN"
  "FOREGROUND_RETRY_SCAN"
  "FOREGROUND_SCAN"
  "UNKNOWN_SCAN_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ScanType_entries[] = {
  { {ScanType_names + 0, 15}, 4 },
  { {ScanType_names + 15, 17}, 3 },
  { {ScanType_names + 32, 21}, 2 },
  { {ScanType_names + 53, 15}, 1 },
  { {ScanType_names + 68, 17}, 0 },
};

static const int ScanType_entries_by_number[] = {
  4, // 0 -> UNKNOWN_SCAN_TYPE
  3, // 1 -> FOREGROUND_SCAN
  2, // 2 -> FOREGROUND_RETRY_SCAN
  1, // 3 -> DIRECT_SHARE_SCAN
  0, // 4 -> BACKGROUND_SCAN
};

const std::string& ScanType_Name(
    ScanType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ScanType_entries,
          ScanType_entries_by_number,
          5, ScanType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ScanType_entries,
      ScanType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ScanType_strings[idx].get();
}
bool ScanType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ScanType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ScanType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ScanType>(int_value);
  }
  return success;
}
bool AdvertisingMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AdvertisingMode_strings[5] = {};

static const char AdvertisingMode_names[] =
  "BACKGROUND_ADVERTISING_MODE"
  "FOREGROUND_ADVERTISING_MODE"
  "MIDGROUND_ADVERTISING_MODE"
  "SCREEN_OFF_ADVERTISING_MODE"
  "UNKNOWN_ADVERTISING_MODE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AdvertisingMode_entries[] = {
  { {AdvertisingMode_names + 0, 27}, 2 },
  { {AdvertisingMode_names + 27, 27}, 4 },
  { {AdvertisingMode_names + 54, 26}, 3 },
  { {AdvertisingMode_names + 80, 27}, 1 },
  { {AdvertisingMode_names + 107, 24}, 0 },
};

static const int AdvertisingMode_entries_by_number[] = {
  4, // 0 -> UNKNOWN_ADVERTISING_MODE
  3, // 1 -> SCREEN_OFF_ADVERTISING_MODE
  0, // 2 -> BACKGROUND_ADVERTISING_MODE
  2, // 3 -> MIDGROUND_ADVERTISING_MODE
  1, // 4 -> FOREGROUND_ADVERTISING_MODE
};

const std::string& AdvertisingMode_Name(
    AdvertisingMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AdvertisingMode_entries,
          AdvertisingMode_entries_by_number,
          5, AdvertisingMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AdvertisingMode_entries,
      AdvertisingMode_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AdvertisingMode_strings[idx].get();
}
bool AdvertisingMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AdvertisingMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AdvertisingMode_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<AdvertisingMode>(int_value);
  }
  return success;
}
bool ActivityName_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ActivityName_strings[13] = {};

static const char ActivityName_names[] =
  "CONSENTS_ACTIVITY"
  "DEVICE_VISIBILITY_ACTIVITY"
  "QUICK_SETTINGS_ACTIVITY"
  "RECEIVE_SURFACE_ACTIVITY"
  "REMOTE_COPY_SHARE_SHEET_ACTIVITY"
  "SETTINGS_ACTIVITY"
  "SETTINGS_REVIEW_ACTIVITY"
  "SETUP_ACTIVITY"
  "SETUP_WIZARD_ACTIVITY"
  "SET_DATA_USAGE_DIALOG"
  "SET_DEVICE_NAME_DIALOG"
  "SHARE_SHEET_ACTIVITY"
  "UNKNOWN_ACTIVITY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ActivityName_entries[] = {
  { {ActivityName_names + 0, 17}, 6 },
  { {ActivityName_names + 17, 26}, 5 },
  { {ActivityName_names + 43, 23}, 9 },
  { {ActivityName_names + 66, 24}, 3 },
  { {ActivityName_names + 90, 32}, 10 },
  { {ActivityName_names + 122, 17}, 2 },
  { {ActivityName_names + 139, 24}, 12 },
  { {ActivityName_names + 163, 14}, 4 },
  { {ActivityName_names + 177, 21}, 11 },
  { {ActivityName_names + 198, 21}, 8 },
  { {ActivityName_names + 219, 22}, 7 },
  { {ActivityName_names + 241, 20}, 1 },
  { {ActivityName_names + 261, 16}, 0 },
};

static const int ActivityName_entries_by_number[] = {
  12, // 0 -> UNKNOWN_ACTIVITY
  11, // 1 -> SHARE_SHEET_ACTIVITY
  5, // 2 -> SETTINGS_ACTIVITY
  3, // 3 -> RECEIVE_SURFACE_ACTIVITY
  7, // 4 -> SETUP_ACTIVITY
  1, // 5 -> DEVICE_VISIBILITY_ACTIVITY
  0, // 6 -> CONSENTS_ACTIVITY
  10, // 7 -> SET_DEVICE_NAME_DIALOG
  9, // 8 -> SET_DATA_USAGE_DIALOG
  2, // 9 -> QUICK_SETTINGS_ACTIVITY
  4, // 10 -> REMOTE_COPY_SHARE_SHEET_ACTIVITY
  8, // 11 -> SETUP_WIZARD_ACTIVITY
  6, // 12 -> SETTINGS_REVIEW_ACTIVITY
};

const std::string& ActivityName_Name(
    ActivityName value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ActivityName_entries,
          ActivityName_entries_by_number,
          13, ActivityName_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ActivityName_entries,
      ActivityName_entries_by_number,
      13, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ActivityName_strings[idx].get();
}
bool ActivityName_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActivityName* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ActivityName_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<ActivityName>(int_value);
  }
  return success;
}
bool ConsentType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConsentType_strings[3] = {};

static const char ConsentType_names[] =
  "CONSENT_TYPE_C11N"
  "CONSENT_TYPE_DEVICE_CONTACT"
  "CONSENT_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConsentType_entries[] = {
  { {ConsentType_names + 0, 17}, 1 },
  { {ConsentType_names + 17, 27}, 2 },
  { {ConsentType_names + 44, 20}, 0 },
};

static const int ConsentType_entries_by_number[] = {
  2, // 0 -> CONSENT_TYPE_UNKNOWN
  0, // 1 -> CONSENT_TYPE_C11N
  1, // 2 -> CONSENT_TYPE_DEVICE_CONTACT
};

const std::string& ConsentType_Name(
    ConsentType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConsentType_entries,
          ConsentType_entries_by_number,
          3, ConsentType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConsentType_entries,
      ConsentType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConsentType_strings[idx].get();
}
bool ConsentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConsentType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConsentType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ConsentType>(int_value);
  }
  return success;
}
bool ConsentAcceptanceStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConsentAcceptanceStatus_strings[4] = {};

static const char ConsentAcceptanceStatus_names[] =
  "CONSENT_ACCEPTED"
  "CONSENT_DECLINED"
  "CONSENT_UNABLE_TO_ENABLE"
  "CONSENT_UNKNOWN_ACCEPT_STATUS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConsentAcceptanceStatus_entries[] = {
  { {ConsentAcceptanceStatus_names + 0, 16}, 1 },
  { {ConsentAcceptanceStatus_names + 16, 16}, 2 },
  { {ConsentAcceptanceStatus_names + 32, 24}, 3 },
  { {ConsentAcceptanceStatus_names + 56, 29}, 0 },
};

static const int ConsentAcceptanceStatus_entries_by_number[] = {
  3, // 0 -> CONSENT_UNKNOWN_ACCEPT_STATUS
  0, // 1 -> CONSENT_ACCEPTED
  1, // 2 -> CONSENT_DECLINED
  2, // 3 -> CONSENT_UNABLE_TO_ENABLE
};

const std::string& ConsentAcceptanceStatus_Name(
    ConsentAcceptanceStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConsentAcceptanceStatus_entries,
          ConsentAcceptanceStatus_entries_by_number,
          4, ConsentAcceptanceStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConsentAcceptanceStatus_entries,
      ConsentAcceptanceStatus_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConsentAcceptanceStatus_strings[idx].get();
}
bool ConsentAcceptanceStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConsentAcceptanceStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConsentAcceptanceStatus_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ConsentAcceptanceStatus>(int_value);
  }
  return success;
}
bool ApkSource_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ApkSource_strings[3] = {};

static const char ApkSource_names[] =
  "APK_FROM_SD_CARD"
  "INSTALLED_APP"
  "UNKNOWN_APK_SOURCE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ApkSource_entries[] = {
  { {ApkSource_names + 0, 16}, 1 },
  { {ApkSource_names + 16, 13}, 2 },
  { {ApkSource_names + 29, 18}, 0 },
};

static const int ApkSource_entries_by_number[] = {
  2, // 0 -> UNKNOWN_APK_SOURCE
  0, // 1 -> APK_FROM_SD_CARD
  1, // 2 -> INSTALLED_APP
};

const std::string& ApkSource_Name(
    ApkSource value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ApkSource_entries,
          ApkSource_entries_by_number,
          3, ApkSource_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ApkSource_entries,
      ApkSource_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ApkSource_strings[idx].get();
}
bool ApkSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ApkSource* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ApkSource_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ApkSource>(int_value);
  }
  return success;
}
bool InstallAPKStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> InstallAPKStatus_strings[3] = {};

static const char InstallAPKStatus_names[] =
  "FAIL_INSTALLATION"
  "SUCCESS_INSTALLATION"
  "UNKNOWN_INSTALL_APK_STATUS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry InstallAPKStatus_entries[] = {
  { {InstallAPKStatus_names + 0, 17}, 1 },
  { {InstallAPKStatus_names + 17, 20}, 2 },
  { {InstallAPKStatus_names + 37, 26}, 0 },
};

static const int InstallAPKStatus_entries_by_number[] = {
  2, // 0 -> UNKNOWN_INSTALL_APK_STATUS
  0, // 1 -> FAIL_INSTALLATION
  1, // 2 -> SUCCESS_INSTALLATION
};

const std::string& InstallAPKStatus_Name(
    InstallAPKStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          InstallAPKStatus_entries,
          InstallAPKStatus_entries_by_number,
          3, InstallAPKStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      InstallAPKStatus_entries,
      InstallAPKStatus_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     InstallAPKStatus_strings[idx].get();
}
bool InstallAPKStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InstallAPKStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      InstallAPKStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<InstallAPKStatus>(int_value);
  }
  return success;
}
bool VerifyAPKStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> VerifyAPKStatus_strings[4] = {};

static const char VerifyAPKStatus_names[] =
  "ALREADY_INSTALLED"
  "INSTALLABLE"
  "NOT_INSTALLABLE"
  "UNKNOWN_VERIFY_APK_STATUS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry VerifyAPKStatus_entries[] = {
  { {VerifyAPKStatus_names + 0, 17}, 3 },
  { {VerifyAPKStatus_names + 17, 11}, 2 },
  { {VerifyAPKStatus_names + 28, 15}, 1 },
  { {VerifyAPKStatus_names + 43, 25}, 0 },
};

static const int VerifyAPKStatus_entries_by_number[] = {
  3, // 0 -> UNKNOWN_VERIFY_APK_STATUS
  2, // 1 -> NOT_INSTALLABLE
  1, // 2 -> INSTALLABLE
  0, // 3 -> ALREADY_INSTALLED
};

const std::string& VerifyAPKStatus_Name(
    VerifyAPKStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          VerifyAPKStatus_entries,
          VerifyAPKStatus_entries_by_number,
          4, VerifyAPKStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      VerifyAPKStatus_entries,
      VerifyAPKStatus_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     VerifyAPKStatus_strings[idx].get();
}
bool VerifyAPKStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VerifyAPKStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      VerifyAPKStatus_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<VerifyAPKStatus>(int_value);
  }
  return success;
}
bool ShowNotificationStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ShowNotificationStatus_strings[3] = {};

static const char ShowNotificationStatus_names[] =
  "NOT_SHOW"
  "SHOW"
  "UNKNOWN_SHOW_NOTIFICATION_STATUS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ShowNotificationStatus_entries[] = {
  { {ShowNotificationStatus_names + 0, 8}, 2 },
  { {ShowNotificationStatus_names + 8, 4}, 1 },
  { {ShowNotificationStatus_names + 12, 32}, 0 },
};

static const int ShowNotificationStatus_entries_by_number[] = {
  2, // 0 -> UNKNOWN_SHOW_NOTIFICATION_STATUS
  1, // 1 -> SHOW
  0, // 2 -> NOT_SHOW
};

const std::string& ShowNotificationStatus_Name(
    ShowNotificationStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ShowNotificationStatus_entries,
          ShowNotificationStatus_entries_by_number,
          3, ShowNotificationStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ShowNotificationStatus_entries,
      ShowNotificationStatus_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ShowNotificationStatus_strings[idx].get();
}
bool ShowNotificationStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShowNotificationStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ShowNotificationStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ShowNotificationStatus>(int_value);
  }
  return success;
}
bool PermissionRequestResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PermissionRequestResult_strings[4] = {};

static const char PermissionRequestResult_names[] =
  "PERMISSION_GRANTED"
  "PERMISSION_REJECTED"
  "PERMISSION_UNABLE_TO_GRANT"
  "PERMISSION_UNKNOWN_REQUEST_RESULT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PermissionRequestResult_entries[] = {
  { {PermissionRequestResult_names + 0, 18}, 1 },
  { {PermissionRequestResult_names + 18, 19}, 2 },
  { {PermissionRequestResult_names + 37, 26}, 3 },
  { {PermissionRequestResult_names + 63, 33}, 0 },
};

static const int PermissionRequestResult_entries_by_number[] = {
  3, // 0 -> PERMISSION_UNKNOWN_REQUEST_RESULT
  0, // 1 -> PERMISSION_GRANTED
  1, // 2 -> PERMISSION_REJECTED
  2, // 3 -> PERMISSION_UNABLE_TO_GRANT
};

const std::string& PermissionRequestResult_Name(
    PermissionRequestResult value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PermissionRequestResult_entries,
          PermissionRequestResult_entries_by_number,
          4, PermissionRequestResult_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PermissionRequestResult_entries,
      PermissionRequestResult_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PermissionRequestResult_strings[idx].get();
}
bool PermissionRequestResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PermissionRequestResult* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PermissionRequestResult_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<PermissionRequestResult>(int_value);
  }
  return success;
}
bool PermissionRequestType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PermissionRequestType_strings[6] = {};

static const char PermissionRequestType_names[] =
  "PERMISSION_AIRPLANE_MODE_OFF"
  "PERMISSION_BLUETOOTH"
  "PERMISSION_LOCATION"
  "PERMISSION_UNKNOWN_TYPE"
  "PERMISSION_WIFI"
  "PERMISSION_WIFI_HOTSPOT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PermissionRequestType_entries[] = {
  { {PermissionRequestType_names + 0, 28}, 1 },
  { {PermissionRequestType_names + 28, 20}, 3 },
  { {PermissionRequestType_names + 48, 19}, 4 },
  { {PermissionRequestType_names + 67, 23}, 0 },
  { {PermissionRequestType_names + 90, 15}, 2 },
  { {PermissionRequestType_names + 105, 23}, 5 },
};

static const int PermissionRequestType_entries_by_number[] = {
  3, // 0 -> PERMISSION_UNKNOWN_TYPE
  0, // 1 -> PERMISSION_AIRPLANE_MODE_OFF
  4, // 2 -> PERMISSION_WIFI
  1, // 3 -> PERMISSION_BLUETOOTH
  2, // 4 -> PERMISSION_LOCATION
  5, // 5 -> PERMISSION_WIFI_HOTSPOT
};

const std::string& PermissionRequestType_Name(
    PermissionRequestType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PermissionRequestType_entries,
          PermissionRequestType_entries_by_number,
          6, PermissionRequestType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PermissionRequestType_entries,
      PermissionRequestType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PermissionRequestType_strings[idx].get();
}
bool PermissionRequestType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PermissionRequestType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PermissionRequestType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<PermissionRequestType>(int_value);
  }
  return success;
}
bool SharingUseCase_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SharingUseCase_strings[8] = {};

static const char SharingUseCase_names[] =
  "USE_CASE_APP_SHARE"
  "USE_CASE_NEARBY_SHARE"
  "USE_CASE_NEARBY_SHARE_WITH_QR_CODE"
  "USE_CASE_QUICK_SETTING_FILE_SHARE"
  "USE_CASE_REMOTE_COPY_PASTE"
  "USE_CASE_SETUP_WIZARD"
  "USE_CASE_UNKNOWN"
  "USE_CASE_WIFI_CREDENTIAL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SharingUseCase_entries[] = {
  { {SharingUseCase_names + 0, 18}, 4 },
  { {SharingUseCase_names + 18, 21}, 1 },
  { {SharingUseCase_names + 39, 34}, 7 },
  { {SharingUseCase_names + 73, 33}, 5 },
  { {SharingUseCase_names + 106, 26}, 2 },
  { {SharingUseCase_names + 132, 21}, 6 },
  { {SharingUseCase_names + 153, 16}, 0 },
  { {SharingUseCase_names + 169, 24}, 3 },
};

static const int SharingUseCase_entries_by_number[] = {
  6, // 0 -> USE_CASE_UNKNOWN
  1, // 1 -> USE_CASE_NEARBY_SHARE
  4, // 2 -> USE_CASE_REMOTE_COPY_PASTE
  7, // 3 -> USE_CASE_WIFI_CREDENTIAL
  0, // 4 -> USE_CASE_APP_SHARE
  3, // 5 -> USE_CASE_QUICK_SETTING_FILE_SHARE
  5, // 6 -> USE_CASE_SETUP_WIZARD
  2, // 7 -> USE_CASE_NEARBY_SHARE_WITH_QR_CODE
};

const std::string& SharingUseCase_Name(
    SharingUseCase value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SharingUseCase_entries,
          SharingUseCase_entries_by_number,
          8, SharingUseCase_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SharingUseCase_entries,
      SharingUseCase_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SharingUseCase_strings[idx].get();
}
bool SharingUseCase_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SharingUseCase* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SharingUseCase_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<SharingUseCase>(int_value);
  }
  return success;
}
bool AppCrashReason_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AppCrashReason_strings[1] = {};

static const char AppCrashReason_names[] =
  "APP_CRASH_REASON_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AppCrashReason_entries[] = {
  { {AppCrashReason_names + 0, 24}, 0 },
};

static const int AppCrashReason_entries_by_number[] = {
  0, // 0 -> APP_CRASH_REASON_UNKNOWN
};

const std::string& AppCrashReason_Name(
    AppCrashReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AppCrashReason_entries,
          AppCrashReason_entries_by_number,
          1, AppCrashReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AppCrashReason_entries,
      AppCrashReason_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AppCrashReason_strings[idx].get();
}
bool AppCrashReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AppCrashReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AppCrashReason_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<AppCrashReason>(int_value);
  }
  return success;
}
bool AttachmentSourceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AttachmentSourceType_strings[6] = {};

static const char AttachmentSourceType_names[] =
  "ATTACHMENT_SOURCE_CONTEXT_MENU"
  "ATTACHMENT_SOURCE_DRAG_AND_DROP"
  "ATTACHMENT_SOURCE_PASTE"
  "ATTACHMENT_SOURCE_SELECT_FILES_BUTTON"
  "ATTACHMENT_SOURCE_SELECT_FOLDERS_BUTTON"
  "ATTACHMENT_SOURCE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AttachmentSourceType_entries[] = {
  { {AttachmentSourceType_names + 0, 30}, 1 },
  { {AttachmentSourceType_names + 30, 31}, 2 },
  { {AttachmentSourceType_names + 61, 23}, 4 },
  { {AttachmentSourceType_names + 84, 37}, 3 },
  { {AttachmentSourceType_names + 121, 39}, 5 },
  { {AttachmentSourceType_names + 160, 25}, 0 },
};

static const int AttachmentSourceType_entries_by_number[] = {
  5, // 0 -> ATTACHMENT_SOURCE_UNKNOWN
  0, // 1 -> ATTACHMENT_SOURCE_CONTEXT_MENU
  1, // 2 -> ATTACHMENT_SOURCE_DRAG_AND_DROP
  3, // 3 -> ATTACHMENT_SOURCE_SELECT_FILES_BUTTON
  2, // 4 -> ATTACHMENT_SOURCE_PASTE
  4, // 5 -> ATTACHMENT_SOURCE_SELECT_FOLDERS_BUTTON
};

const std::string& AttachmentSourceType_Name(
    AttachmentSourceType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AttachmentSourceType_entries,
          AttachmentSourceType_entries_by_number,
          6, AttachmentSourceType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AttachmentSourceType_entries,
      AttachmentSourceType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AttachmentSourceType_strings[idx].get();
}
bool AttachmentSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AttachmentSourceType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AttachmentSourceType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<AttachmentSourceType>(int_value);
  }
  return success;
}
bool PreferencesAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PreferencesAction_strings[12] = {};

static const char PreferencesAction_names[] =
  "PREFERENCES_ACTION_ATTEMPT_LOAD"
  "PREFERENCES_ACTION_CHECK_IF_PREFERENCES_BACKUP_FILE_EXISTS"
  "PREFERENCES_ACTION_CHECK_IF_PREFERENCES_FILE_IS_CORRUPTED"
  "PREFERENCES_ACTION_CHECK_IF_PREFERENCES_INPUT_STREAM_STATUS"
  "PREFERENCES_ACTION_CHECK_IF_PREFERENCES_PATH_EXISTS"
  "PREFERENCES_ACTION_CREATE_PREFERENCES_PATH"
  "PREFERENCES_ACTION_LOAD_PREFERENCES"
  "PREFERENCES_ACTION_MAKE_PREFERENCES_BACKUP_FILE"
  "PREFERENCES_ACTION_NO_ACTION"
  "PREFERENCES_ACTION_RESTORE_FROM_BACKUP"
  "PREFERENCES_ACTION_SAVE_PREFERENCESS"
  "PREFERENCES_ACTION_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PreferencesAction_entries[] = {
  { {PreferencesAction_names + 0, 31}, 4 },
  { {PreferencesAction_names + 31, 58}, 11 },
  { {PreferencesAction_names + 89, 57}, 10 },
  { {PreferencesAction_names + 146, 59}, 9 },
  { {PreferencesAction_names + 205, 51}, 8 },
  { {PreferencesAction_names + 256, 42}, 6 },
  { {PreferencesAction_names + 298, 35}, 2 },
  { {PreferencesAction_names + 333, 47}, 7 },
  { {PreferencesAction_names + 380, 28}, 1 },
  { {PreferencesAction_names + 408, 38}, 5 },
  { {PreferencesAction_names + 446, 36}, 3 },
  { {PreferencesAction_names + 482, 26}, 0 },
};

static const int PreferencesAction_entries_by_number[] = {
  11, // 0 -> PREFERENCES_ACTION_UNKNOWN
  8, // 1 -> PREFERENCES_ACTION_NO_ACTION
  6, // 2 -> PREFERENCES_ACTION_LOAD_PREFERENCES
  10, // 3 -> PREFERENCES_ACTION_SAVE_PREFERENCESS
  0, // 4 -> PREFERENCES_ACTION_ATTEMPT_LOAD
  9, // 5 -> PREFERENCES_ACTION_RESTORE_FROM_BACKUP
  5, // 6 -> PREFERENCES_ACTION_CREATE_PREFERENCES_PATH
  7, // 7 -> PREFERENCES_ACTION_MAKE_PREFERENCES_BACKUP_FILE
  4, // 8 -> PREFERENCES_ACTION_CHECK_IF_PREFERENCES_PATH_EXISTS
  3, // 9 -> PREFERENCES_ACTION_CHECK_IF_PREFERENCES_INPUT_STREAM_STATUS
  2, // 10 -> PREFERENCES_ACTION_CHECK_IF_PREFERENCES_FILE_IS_CORRUPTED
  1, // 11 -> PREFERENCES_ACTION_CHECK_IF_PREFERENCES_BACKUP_FILE_EXISTS
};

const std::string& PreferencesAction_Name(
    PreferencesAction value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PreferencesAction_entries,
          PreferencesAction_entries_by_number,
          12, PreferencesAction_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PreferencesAction_entries,
      PreferencesAction_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PreferencesAction_strings[idx].get();
}
bool PreferencesAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PreferencesAction* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PreferencesAction_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<PreferencesAction>(int_value);
  }
  return success;
}
bool PreferencesActionStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PreferencesActionStatus_strings[3] = {};

static const char PreferencesActionStatus_names[] =
  "PREFERENCES_ACTION_STATUS_FAIL"
  "PREFERENCES_ACTION_STATUS_SUCCESS"
  "PREFERENCES_ACTION_STATUS_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PreferencesActionStatus_entries[] = {
  { {PreferencesActionStatus_names + 0, 30}, 2 },
  { {PreferencesActionStatus_names + 30, 33}, 1 },
  { {PreferencesActionStatus_names + 63, 33}, 0 },
};

static const int PreferencesActionStatus_entries_by_number[] = {
  2, // 0 -> PREFERENCES_ACTION_STATUS_UNKNOWN
  1, // 1 -> PREFERENCES_ACTION_STATUS_SUCCESS
  0, // 2 -> PREFERENCES_ACTION_STATUS_FAIL
};

const std::string& PreferencesActionStatus_Name(
    PreferencesActionStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PreferencesActionStatus_entries,
          PreferencesActionStatus_entries_by_number,
          3, PreferencesActionStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PreferencesActionStatus_entries,
      PreferencesActionStatus_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PreferencesActionStatus_strings[idx].get();
}
bool PreferencesActionStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PreferencesActionStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PreferencesActionStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<PreferencesActionStatus>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace sharing
}  // namespace proto
}  // namespace nearby
}  // namespace location
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
