/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import '../../elevation/elevation.js';
import '../../focus/focus-ring.js';
import '../../ripple/ripple.js';
import { LitElement, PropertyValues } from 'lit';
import { getFormValue } from '../../controller/form-controller.js';
/**
 * Slider component.
 */
export declare class Slider extends LitElement {
    static shadowRootOptions: ShadowRootInit;
    /**
     * @nocollapse
     */
    static formAssociated: boolean;
    /**
     * Whether or not the slider is disabled.
     */
    disabled: boolean;
    /**
     * The slider minimum value
     */
    min: number;
    /**
     * The slider maximum value
     */
    max: number;
    /**
     * The slider value, can be a single number, or an array tuple indicating
     * a start and end value.
     */
    value: number | [number, number];
    /**
     * An optinoal label for the slider's value; if not set, the label is the
     * value itself. This can be a string or string tuple when start and end
     * values are used.
     */
    valueLabel?: string | [string, string] | undefined;
    /**
     * The step between values.
     */
    step: number;
    /**
     * Whether or not to show tick marks.
     */
    withTickMarks: boolean;
    /**
     * Whether or not to show a value label when activated.
     */
    withLabel: boolean;
    /**
     * The HTML name to use in form submission.
     */
    name: string;
    /**
     * The associated form element with which this element's value will submit.
     */
    get form(): HTMLFormElement;
    /**
     * Read only computed value representing the fraction between 0 and 1
     * respresenting the value's position between min and max. This is a
     * single fraction or a tuple if the value specifies start and end values.
     */
    get valueAsFraction(): number | number[];
    private getMetrics;
    private readonly inputA;
    private readonly handleA;
    private readonly rippleA;
    private readonly inputB;
    private readonly handleB;
    private readonly rippleB;
    private valueA;
    private valueB;
    private rippleAShowing;
    private rippleBShowing;
    private handleAHover;
    private handleBHover;
    private onTopId;
    private handlesOverlapping;
    constructor();
    focus(): void;
    get valueAsString(): string;
    [getFormValue](): string;
    private allowRange;
    private isFlipped;
    protected willUpdate(changed: PropertyValues): void;
    protected updated(changed: PropertyValues): Promise<void>;
    protected render(): import("lit-html").TemplateResult<1>;
    private renderTrack;
    private renderLabel;
    private renderHandle;
    private renderInput;
    private readonly renderRipple;
    private readonly getRippleA;
    private readonly getRippleB;
    private toggleRippleHover;
    private isEventOnA;
    private handleFocus;
    private ripplePointerId;
    private handleDown;
    /**
     * The move handler tracks handle hovering to facilitate proper ripple
     * behavior on the slider handle. This is needed because user interaction with
     * the native input is leveraged to position the handle. Because the separate
     * displayed handle element has pointer events disabled (to allow interaction
     * with the input) and the input's handle is a pseudo-element, neither can be
     * the ripple's interactive element. Therefore the input is the ripple's
     * interactive element and has a `ripple` directive; however the ripple
     * is gated on the handle being hovered. In addition, because the ripple
     * hover state is being specially handled, it must be triggered independent
     * of the directive. This is done based on the hover state when the
     * slider is updated.
     */
    private handleMove;
    private handleEnter;
    private handleLeave;
    private updateOnTop;
    private handleInput;
    private handleChange;
}
