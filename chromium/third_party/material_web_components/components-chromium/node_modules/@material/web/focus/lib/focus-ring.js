/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { __decorate } from "tslib";
import { LitElement } from 'lit';
import { property } from 'lit/decorators.js';
/**
 * A focus ring component.
 */
export class FocusRing extends LitElement {
    constructor() {
        super(...arguments);
        /**
         * Makes the focus ring visible.
         */
        this.visible = false;
        /**
         * Reflects the value of the `for` attribute, which is the ID of the focus
         * ring's associated control element.
         *
         * Use this when the focus ring's associated element is not a parent element.
         *
         * To manually control a focus ring, set its `for` attribute to `""`.
         *
         * @example
         * ```html
         * <div class="container">
         *   <md-focus-ring for="interactive"></md-focus-ring>
         *   <button id="interactive">Action</button>
         * </div>
         * ```
         *
         * @example
         * ```html
         * <button class="manually-controlled">
         *   <md-focus-ring visible for=""></md-focus-ring>
         * </button>
         * ```
         */
        this.htmlFor = null;
        this.currentControl = null;
    }
    /**
     * The element that controls the visibility of the focus ring. It is one of:
     *
     * - The element referenced by the `for` attribute.
     * - The element provided to `.attach(element)`
     * - The parent element.
     * - `null` if the focus ring is not controlled.
     */
    get control() {
        if (this.hasAttribute('for')) {
            if (!this.htmlFor) {
                return null;
            }
            return this.getRootNode()
                .querySelector(`#${this.htmlFor}`);
        }
        return this.currentControl || this.parentElement;
    }
    /**
     * Attaches the focus ring to an interactive element.
     *
     * @param control The element that controls the focus ring.
     */
    attach(control) {
        if (control === this.currentControl) {
            return;
        }
        this.setCurrentControl(control);
        // When imperatively attaching the focus ring, remove the `for` attribute so
        // that the attached control is used instead of a referenced one.
        this.removeAttribute('for');
    }
    /**
     * Detaches the focus ring from its current interactive element.
     */
    detach() {
        this.setCurrentControl(null);
        // When imperatively detaching, add an empty `for=""` attribute. This will
        // ensure the control is `null` rather than the `parentElement`.
        this.setAttribute('for', '');
    }
    connectedCallback() {
        super.connectedCallback();
        this.setCurrentControl(this.control);
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this.setCurrentControl(null);
    }
    updated(changedProperties) {
        if (changedProperties.has('htmlFor')) {
            const { control } = this;
            if (control) {
                this.setCurrentControl(control);
            }
        }
    }
    /**
     * @private
     */
    handleEvent(event) {
        if (event[HANDLED_BY_FOCUS_RING]) {
            // This ensures the focus ring does not activate when multiple focus rings
            // are used within a single component.
            return;
        }
        switch (event.type) {
            default:
                return;
            case 'focusin':
                this.visible = this.control?.matches(':focus-visible') ?? false;
                break;
            case 'focusout':
            case 'pointerdown':
                this.visible = false;
                break;
        }
        event[HANDLED_BY_FOCUS_RING] = true;
    }
    setCurrentControl(control) {
        for (const event of ['focusin', 'focusout', 'pointerdown']) {
            this.currentControl?.removeEventListener(event, this);
            control?.addEventListener(event, this);
        }
        this.currentControl = control;
    }
}
__decorate([
    property({ type: Boolean, reflect: true })
], FocusRing.prototype, "visible", void 0);
__decorate([
    property({ attribute: 'for', reflect: true })
], FocusRing.prototype, "htmlFor", void 0);
const HANDLED_BY_FOCUS_RING = Symbol('handledByFocusRing');
//# sourceMappingURL=focus-ring.js.map