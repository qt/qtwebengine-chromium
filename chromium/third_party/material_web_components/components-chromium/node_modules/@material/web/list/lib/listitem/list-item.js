/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var _a;
import { __decorate } from "tslib";
import '../../../ripple/ripple.js';
import '../../../focus/focus-ring.js';
import { html, LitElement, nothing } from 'lit';
import { property, query, queryAsync, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { requestUpdateOnAriaChange } from '../../../aria/delegate.js';
import { ripple } from '../../../ripple/directive.js';
// tslint:disable-next-line:enforce-comments-on-exported-symbols
export class ListItemEl extends LitElement {
    constructor() {
        super(...arguments);
        /**
         * The primary, headline text of the list item.
         */
        this.headline = '';
        /**
         * The one-line supporting text below the headline. Set
         * `multiLineSupportingText` to `true` to support multiple lines in the
         * supporting text.
         */
        this.supportingText = '';
        /**
         * Modifies `supportingText` to support multiple lines.
         */
        this.multiLineSupportingText = false;
        /**
         * The supporting text placed at the end of the item. Overriden by elements
         * slotted into the `end` slot.
         */
        this.trailingSupportingText = '';
        /**
         * Disables the item and makes it non-selectable and non-interactive.
         */
        this.disabled = false;
        /**
         * The tabindex of the underlying item.
         *
         * __NOTE:__ this is overriden by the keyboard behavior of `md-list` and by
         * setting `selected`.
         */
        this.itemTabIndex = -1;
        /**
         * Whether or not the element is actively being interacted with by md-list.
         * When active, tabindex is set to 0, and in some list item variants (like
         * md-list-item), focuses the underlying item.
         */
        this.active = false;
        /**
         * READONLY. Sets the `md-list-item` attribute on the element.
         */
        this.isListItem = true;
        this.listItemRole = 'listitem';
        this.showRipple = false;
        /**
         * Only meant to be overriden by subclassing and not by the user. This is
         * so that we have control over focus on specific variants such as disabling
         * focus on <md-autocomplete-item> but enabling it for <md-menu-item>.
         */
        this.focusOnActivation = true;
        this.getRipple = () => {
            this.showRipple = true;
            return this.ripple;
        };
        this.isFirstUpdate = true;
    }
    willUpdate(changed) {
        if (changed.has('active') && !this.disabled) {
            if (this.active) {
                this.itemTabIndex = 0;
            }
            else if (!this.isFirstUpdate) {
                // Do not reset anything if it's the first render because user could
                // have set `itemTabIndex` manually.
                this.itemTabIndex = -1;
            }
        }
    }
    render() {
        return this.renderListItem(html `
      <div class="content-wrapper">
        ${this.renderStart()}
        ${this.renderBody()}
        ${this.renderEnd()}
        ${this.renderRipple()}
        ${this.renderFocusRing()}
      </div>`);
    }
    /**
     * Renders the root list item.
     *
     * @param content {unkown} the child content of the list item.
     */
    renderListItem(content) {
        return html `
      <li
          id="item"
          tabindex=${this.disabled ? -1 : this.itemTabIndex}
          role=${this.listItemRole}
          aria-selected=${this.ariaSelected || nothing}
          aria-checked=${this.ariaChecked || nothing}
          class="list-item ${classMap(this.getRenderClasses())}"
          @click=${this.onClick}
          @pointerenter=${this.onPointerenter}
          @pointerleave=${this.onPointerleave}
          @keydown=${this.onKeydown}
          ${ripple(this.getRipple)}>${content}</li>`;
    }
    /**
     * Handles rendering of the ripple element.
     */
    renderRipple() {
        return this.showRipple ?
            html `<md-ripple ?disabled="${this.disabled}"></md-ripple>` :
            nothing;
    }
    /**
     * Handles rendering of the focus ring.
     */
    renderFocusRing() {
        return html `<md-focus-ring class="focus-ring" for="item"></md-focus-ring>`;
    }
    /**
     * Classes applied to the list item root.
     */
    getRenderClasses() {
        return {
            'with-one-line': this.supportingText === '',
            'with-two-line': this.supportingText !== '' && !this.multiLineSupportingText,
            'with-three-line': this.supportingText !== '' && this.multiLineSupportingText,
            'disabled': this.disabled
        };
    }
    /**
     * The content rendered at the start of the list item.
     */
    renderStart() {
        return html `<div class="start"><slot name="start"></slot></div>`;
    }
    /**
     * Handles rendering the headline and supporting text.
     */
    renderBody() {
        const supportingText = this.supportingText !== '' ? this.renderSupportingText() : '';
        return html `<div class="body"
      ><span class="label-text">${this.headline}</span>${supportingText}</div>`;
    }
    /**
     * Renders the one-line supporting text.
     */
    renderSupportingText() {
        return html `<span
        class="supporting-text ${classMap(this.getSupportingTextClasses())}"
      >${this.supportingText}</span>`;
    }
    /**
     * Gets the classes for the supporting text node
     */
    getSupportingTextClasses() {
        return { 'supporting-text--multi-line': this.multiLineSupportingText };
    }
    /**
     * The content rendered at the end of the list item.
     */
    renderEnd() {
        const supportingText = this.trailingSupportingText !== '' ?
            this.renderTrailingSupportingText() :
            '';
        return html `<div class="end"
      ><slot name="end">${supportingText}</slot></div>`;
    }
    /**
     * Renders the supporting text at the end of the list item.
     */
    renderTrailingSupportingText() {
        return html `<span class="trailing-supporting-text"
      >${this.trailingSupportingText}</span>`;
    }
    updated(changed) {
        super.updated(changed);
        // will focus the list item root if it is selected but not on the first
        // update or else it may cause the page to jump on first load.
        if (changed.has('active') && !this.isFirstUpdate && this.active &&
            this.focusOnActivation) {
            this.focus();
        }
        this.isFirstUpdate = false;
    }
    focus() {
        this.listItemRoot?.focus?.();
    }
}
_a = ListItemEl;
(() => {
    requestUpdateOnAriaChange(_a);
})();
__decorate([
    property()
], ListItemEl.prototype, "headline", void 0);
__decorate([
    property()
], ListItemEl.prototype, "supportingText", void 0);
__decorate([
    property({ type: Boolean })
], ListItemEl.prototype, "multiLineSupportingText", void 0);
__decorate([
    property()
], ListItemEl.prototype, "trailingSupportingText", void 0);
__decorate([
    property({ type: Boolean })
], ListItemEl.prototype, "disabled", void 0);
__decorate([
    property({ type: Number })
], ListItemEl.prototype, "itemTabIndex", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], ListItemEl.prototype, "active", void 0);
__decorate([
    property({ type: Boolean, attribute: 'md-list-item', reflect: true })
], ListItemEl.prototype, "isListItem", void 0);
__decorate([
    queryAsync('md-ripple')
], ListItemEl.prototype, "ripple", void 0);
__decorate([
    query('.list-item')
], ListItemEl.prototype, "listItemRoot", void 0);
__decorate([
    state()
], ListItemEl.prototype, "showRipple", void 0);
//# sourceMappingURL=list-item.js.map