/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var _a;
import { __decorate } from "tslib";
import '../../focus/focus-ring.js';
import '../../icon/icon.js';
import '../../ripple/ripple.js';
import { html, LitElement, nothing } from 'lit';
import { property, queryAsync, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { when } from 'lit/directives/when.js';
import { html as staticHtml, literal } from 'lit/static-html.js';
import { requestUpdateOnAriaChange } from '../../aria/delegate.js';
import { isRtl } from '../../controller/is-rtl.js';
import { ripple } from '../../ripple/directive.js';
// tslint:disable-next-line:enforce-comments-on-exported-symbols
export class IconButton extends LitElement {
    constructor() {
        super(...arguments);
        /**
         * Disables the icon button and makes it non-interactive.
         */
        this.disabled = false;
        /**
         * Flips the icon if it is in an RTL context at startup.
         */
        this.flipIconInRtl = false;
        /**
         * Sets the underlying `HTMLAnchorElement`'s `href` resource attribute.
         */
        this.href = '';
        /**
         * Sets the underlying `HTMLAnchorElement`'s `target` attribute.
         */
        this.target = '';
        /**
         * When true, the button will toggle between selected and unselected
         * states
         */
        this.toggle = false;
        /**
         * Sets the selected state. When false, displays the default icon. When true,
         * displays the `selectedIcon`, or the default icon If no `selectedIcon` is
         * provided.
         */
        this.selected = false;
        this.showRipple = false;
        this.flipIcon = isRtl(this, this.flipIconInRtl);
        this.getRipple = () => {
            this.showRipple = true;
            return this.ripple;
        };
        this.renderRipple = () => {
            return html `<md-ripple ?disabled="${!this.href && this.disabled}"></md-ripple>`;
        };
    }
    /**
     * Link buttons cannot be disabled.
     */
    willUpdate() {
        if (this.href) {
            this.disabled = false;
        }
    }
    render() {
        const tag = this.href ? literal `div` : literal `button`;
        // Needed for closure conformance
        const { ariaLabel, ariaHasPopup, ariaExpanded } = this;
        const hasToggledAriaLabel = ariaLabel && this.selectedAriaLabel;
        const ariaPressedValue = hasToggledAriaLabel ? nothing : this.selected;
        let ariaLabelValue = nothing;
        if (!this.href) {
            ariaLabelValue = (hasToggledAriaLabel && this.selected) ?
                this.selectedAriaLabel :
                ariaLabel;
        }
        return staticHtml `<${tag}
        class="md3-icon-button ${classMap(this.getRenderClasses())}"
        id="button"
        aria-label="${ariaLabelValue || nothing}"
        aria-haspopup="${!this.href && ariaHasPopup || nothing}"
        aria-expanded="${!this.href && ariaExpanded || nothing}"
        aria-pressed="${ariaPressedValue}"
        ?disabled="${!this.href && this.disabled}"
        @click="${this.handleClick}"
        ${ripple(this.getRipple)}>
        ${this.renderFocusRing()}
        ${when(this.showRipple, this.renderRipple)}
        ${!this.selected ? this.renderIcon() : nothing}
        ${this.selected ? this.renderSelectedIcon() : nothing}
        ${this.renderTouchTarget()}
        ${this.href && this.renderLink()}
  </${tag}>`;
    }
    renderLink() {
        // Needed for closure conformance
        const { ariaLabel } = this;
        return html `
      <a class="md3-icon-button__link"
        id="link"
        href="${this.href}"
        target="${this.target || nothing}"
        aria-label="${ariaLabel || nothing}"
        ${ripple(this.getRipple)}
      ></a>
    `;
    }
    getRenderClasses() {
        return {
            'md3-icon-button--flip-icon': this.flipIcon,
            'md3-icon-button--selected': this.toggle && this.selected,
        };
    }
    renderIcon() {
        return html `<md-icon class="md3-icon-button__icon"><slot></slot></md-icon>`;
    }
    renderSelectedIcon() {
        // Use default slot as fallback to not require specifying multiple icons
        return html `<md-icon class="md3-icon-button__icon md3-icon-button__icon--selected"><slot name="selectedIcon"><slot></slot></slot></md-icon>`;
    }
    renderTouchTarget() {
        return html `<span class="md3-icon-button__touch"></span>`;
    }
    renderFocusRing() {
        return html `<md-focus-ring for=${this.href ? 'link' : 'button'}></md-focus-ring>`;
    }
    connectedCallback() {
        this.flipIcon = isRtl(this, this.flipIconInRtl);
        super.connectedCallback();
    }
    handleClick() {
        if (!this.toggle || this.disabled) {
            return;
        }
        this.selected = !this.selected;
        this.dispatchEvent(new InputEvent('input', { bubbles: true, composed: true }));
        // Bubbles but does not compose to mimic native browser <input> & <select>
        // Additionally, native change event is not an InputEvent.
        this.dispatchEvent(new Event('change', { bubbles: true }));
    }
}
_a = IconButton;
(() => {
    requestUpdateOnAriaChange(_a);
})();
__decorate([
    property({ type: Boolean, reflect: true })
], IconButton.prototype, "disabled", void 0);
__decorate([
    property({ type: Boolean })
], IconButton.prototype, "flipIconInRtl", void 0);
__decorate([
    property()
], IconButton.prototype, "href", void 0);
__decorate([
    property()
], IconButton.prototype, "target", void 0);
__decorate([
    property({ attribute: 'selected-aria-label', reflect: true })
], IconButton.prototype, "selectedAriaLabel", void 0);
__decorate([
    property({ type: Boolean })
], IconButton.prototype, "toggle", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], IconButton.prototype, "selected", void 0);
__decorate([
    queryAsync('md-ripple')
], IconButton.prototype, "ripple", void 0);
__decorate([
    state()
], IconButton.prototype, "showRipple", void 0);
__decorate([
    state()
], IconButton.prototype, "flipIcon", void 0);
//# sourceMappingURL=icon-button.js.map